## 목차
[본딩은 모놀리식 애플리케이션?](#본딩은-모놀리식-애플리케이션?)  
[알림 서비스 때 했던 고민들](#알림-서비스-때-했던-고민들)  
[중단 없이 재빠르게 움지..ㄱ..여라.....](#중단-없이-재빠르게-움지..ㄱ..여라.....)  
[책 내용 기록](#1장-모놀리식-지옥에서-벗어나라)  
[책거리할 때 나](#책거리할-때-나)

**monolith**  
🍝haphazardly structured, spawling, sloppy, duct-tape and bailing wire, spaghetti code jungle

# 본딩은 모놀리식 애플리케이션?

![image](https://user-images.githubusercontent.com/52988414/148598520-639e566f-b518-4aa3-83a2-43147e7b8cd9.png)

# 알림 서비스 때 했던 고민들

알림서비스 Y축확장: 기능에 따라 애플리케이션을 서비스로 분해

알림서비스 Z축 확장: 요청 속성별 라우팅(파티셔닝)

# 중단 없이 재빠르게 움지..ㄱ..여라.....

부끄럽지만 자동화 하나 없이 하고 있다.

다음은 책에서 설명하는 소프트웨어 개발 수준을 평가하는 네 가지 잣대인데 많이 반성했다.

1. 배포 빈도(deployment frequency)
    
    아주아주 자주 프로덕션에 배포한다.
    
    기능별로 브랜치를 만들고 그 브랜치를 닫을 때마다 배포한다.
    
2. 리드 타임(lead time)
    
    아주 짧다. 다음 3, 4문항을 보면 이해가 될 것이다.
    
3. 평균 복구 시간(MTTR, mean time to recover)
    
    앞서 말했듯이 알림서비스를 제외하고 모놀리식으로 운영중이다.
    
    결함 격리는 물론이고 로깅도 불완전하다..
    
4. 변경분 실패율
    
    정말정말 글로 쓰고 싶지 않았는데 높다..!.. 꽤...
    
    팀프앙(리브랜딩 전 본딩) 개발 중엔 나름 테스트 코드를 적으려 노력했다. 그런데 서비스 크기가 작았기도 했고 테스트 자동화의 중요성을 잘 몰랐다. 그후 빠른 시일에 본딩을 만든다고 테스트 코드는 물론 자동화를 구현하지 않았는데 요즘 아주 고통스럽다.
    
    하나하나 테스트를 수동으로 하기도 어렵고 실패율도 높은 편이다.
    

# 1장 모놀리식 지옥에서 벗어나라

## 처음 모놀리식 아키텍처를 선택할 당시에는 올바른 선택이었겠죠.

1. 개발이 간단하다.
2. 애플리케이션을 쉽게 변경할 수 있다.
3. 테스트하기 쉽다.
4. 배포하기 쉽다.
5. 확장하기 쉽다. : load balancer에 인스턴스를 여러 개 실행

## 실상

아키텍처가 몸에 맞지 않게 되니 모놀리식 지옥에 빠져 지금은 애자일식 개발/배포도 불가능함.

1. 너무 복잡해
2. 개발이 더뎌: IDE 실행 속도, 빌드시간
3. 커밋부터 배포 숨막혀
4. 확장하기 어려워: 모듈마다 상이한 리소스 요건
5. 확실하게 전달 못해: 결함 격리 불가
6. 한물간 기술스택에 묶여: 버전 호환 안돼

## 선수지식

- 3계층 아키텍처
- 웹 애플리케이션 설계
- 객체 지향 설계를 응용한 비즈니스 로직 개발
- RDBMS 사용법: SQL, ACID 트랜잭션
- 메시지 브로커와 REST AOI를 활용한 IPC
- 인증/인가 등 보안 개념

## 책거리할 때 나

- [ ]  마이크로서비스 아키텍처 패턴으로 애플리케이션을 아키텍처링할 수 있음.
- [ ]  서비스 비즈니스 로직을 개발할 수 있음.
- [ ]  사가를 이용하여 서비스 간 데이터 일관성을 유지할 수 있음.
- [ ]  여러 서비스에 걸친 쿼리를 구현할 수 있음.
- [ ]  마이크로서비스를 효율적으로 테스할 수 있음.
- [ ]  안전하고, 구성 가능하고, 관측 가능한 프로덕션 레디 서비스를 개발할 수 있음.
- [ ]  기존 모놀리식 애플리케이션을 마이크로서비스로 리팩터링할 수 있음.

## nonfunctional requirement

maintaianabilit  
extensibility  
testability  

## 확장 큐브

### Z축 확장

> 증가하는 트랜잭션 및 데이터 볼륨을 처리하기 좋은 수단
> 

### Y축 확장

> 각 미니 애플리케이션이 focused/cohesive 책임을 맡음.
> 

## 마이크로서비스 아키텍처의 단점

1. 분산 모놀리스를 구축할지도: 분산되버린 결합도 높은 서비스들
2. 분산 시스템 복잡해
3. 여러 서비스에 걸친 공통 기능 배포는 주의해
4. 언제 도입하냐

## 마이크로서비스 아키텍처 패턴 언어

패턴: 특정한 상황에서 발생한 문제이 대한 **재사용 가능한 해법**

패턴 언어: 특정 영역 내부에서 문제를 해결하는 연관된 **패턴의 집합**.

### 상용 패턴의 구조

패턴은 맥락을 고려하게 만드는 것 외에도, 매우 중요하지만 자주 간과되는 손루션의 축면도 함게 기술하도록 강제한다는 점에서 효용성이 크다.

- 강제 조항(foces): 문제 해결을 위해 반드시 처리해야할 이슈, 우선순위를 두자
- 결과 맥락(resulting context): 패턱 적용 결과 - 장점, 단점, 이슈
- 연관 패턴(related patterns)

### 패턴의 3 계층

- 인프라 패턴: 주로 개발 영역 밖의 인프라 문제 해결
- 애플리케이션 인프라: 개발에도 영향을 미치는 인프라 문제 해결
- 애플리케이션 패턴: 개발자가 맞닥뜨리는 문제 해결

**서비스 배포 패턴** `인프라`
서비스 배포 플랫폼 → (호스트별 단일 서비스)VM,컨테이너에 배포 ↔ 서버리스 ↔ 호스트별 다중 서비스

**통신 스타일** `애플리케이션 인프라`
어떻 종류의 IPC를 사용하는가?

**신뢰성** `애플리케이션 인프라`
서비스 불능 시 서비스 간 통신의 신뢰성은 어떻게 보장되는가?

**트랜잭셔널 메시징** `애플리케이션 인프라`
비즈니스 데이터를 업데이트하는 DB 트랜잭션에 메시지를 송신하고 이벤트를 발행하는 행위를 어떻게 통합하는가?

**디스커버리** `인프라` `애플리케이션 인프라`
서비스 클라이언트는 서비스 인스턴스의 IP주소를 어떻게 가져오는가?

**외부 API** `인프라`
애플리케이션 클라이언트는 서비스와 어떻게 통신하는가?

**관측성 패턴** `애플리케이션 인프라` `애플리케이션`
마이크로서비스 아키텍처는 요청 결과가 클라이언트에 반환되기까지 어떤 서비스를 어떻게 오갈지 알 수 없음.

헬스 체크(helth check), 로그 수집(log aggregation), 분산 추적(distributed tracing), 에외 추적(execption tracking), 애플리케이션 지표(application metrics), 감사 로깅(audit logging)

**횡단 관심사 처리 패턴** `애플리케이션 인프라`
모든 서비스가 반드시 구현해야 할 관심사들, DB 자격증명 같은 구성 매개변수를 런타임 서비스에 제공하는 외부화 구성 패턴

**보안 패턴** `애플리케이션 인프라`
API 게이트웨이가 신원, 역할 등 사용자 정보를 인증 후 호출할 서비스에 관련 정보 전달  
ex) API 게이트웨이는 액세스 토큰을 서비스에 건네고 서비스는 토큰 확인 후 사용저 정보 조회

**애플리케이션을 여러 서비스로 분해하는 패턴**`애플리케이션`
비즈니스 능력에 따라 분해↔하위 도메인에 따라 분해

**트랜잭션 관리를 위한 데이터 일관성 패턴**`애플리케이션`
서비스별 DB → 사가 →애그리거트

**데이터 쿼리 패턴**`애플리케이션`
서비스별 DB → API 조합: 결과 조합 ↔ CQRS: 데이터 레플리카

**서비스 테스트 자동화 패턴**`애플리케이션`
- 컨슈머 주도 계약 테스트: 클라이언트가 의도한 대로 서비스가 동작하는가
- 컨슈머 쪽 계약 테스트: 클라이언트와 서비스가 상호 통신 가능한가
- 서비스 컴포넌트 테스트: 서비스를 따로따로 테스트

## 전달 조직| N명 팀의 소통 오버헤드는 O(N^2)
범기능 팀을 구성하면 다른 팀과 매번 소통하거나 협의하지 않고 서비스를 독자적으로 개발, 테스트, 배포할 수 있습니다.

🐸선배가 토스의 팀이 이런 구성이라고 하셨는데 대단하다고 생각한다.

**역 콘웨이 전략**

> 시스템을 설계하는 조직은 ...... 그들이 소통하는 구조를 그대로 옮겨 놓은 듯한 결과물을 낼 수 밖에 없는 한계가 있다.
> 

조직의 구조가 마이크로서비스 아키텍처에 고스란히 반영되도록 설계해야한다. 이렇게 하면 개발 팀과 서비스를 느슨하게 결합시킬 수 있습니다.

## 전달 프로세스

지속적 전달/배포(데브옵스)  
소프트웨어를 언제라도 릴리스 할 수 있는 능력  
높은 수준의 자동화  
릴리스 가능한 코드를 프로덕션에 자동 배포

🐸작년 딱 이맘때, 동아리에서 해커톤을 나갔다. 팀에 서버를 맡은 선배가 이런 구조로 구현하셨었는데 이제야 조금 알 것같다.
